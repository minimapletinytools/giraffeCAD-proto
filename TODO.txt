:: 12/29/2025 mortise and tenon notes



this function is very generic and does a bunch of things. in particluar we want the following variants which will all call into this function;

      -mortise and tenon
      -through mortise and tenon
      -wedged mortise and tenon
      -wedged through mortise and tenon
      -fox wedge mortise and tenon
      -draw bore mortise and tenon
      -Hōzo-zashi Komisen-dome (ほぞ差し込み栓止め)
        -same as draw bore but with komisen peg,
      -tusked mortise and tenon 


for now, create the super generic 

cut_mortise_and_tenon_many_options_do_not_call_me_directly

then do simple_mortise_and_tenon function that has no pegs or wedges

the cut_mortise_and_tenon_many_options_do_not_call_me_directly function, it should take the following parameters

-tenon timber
-mortise timber
-tenon end (of the tenon timber)
-size (X,Y cross sectional size of tenon in local space of the tenon timber)
-tenon_length
-mortise_depth (must be >= to tenon length, if none, then it's a through mortise)
-tenon_rotation (ccw rotation of tenon, identity by default )
-wedges parameters (optional)
-peg parameters (otpional)


for implemntation, for now, assert on wedge and peg parameters being none, we will implement them later. also assert tenon_rotation is identity.


stub out the peg and wedge praameter classes below though

class SimplePegParameters
  shape: PegShape
  tenon_face: TimberLongFace # the face on the TENON timber that the pegs will be perpendicular too, only valid if tenon_rotation is identity
  peg_positions: [(Numeric, Numeric)] # first is in length axis measured from the shoulder of the tenon, the second is in the perpendicular axis measured from center
  depth: Optinoal[Numeric] # measured from mortise face where the peg goes in, none means peg goes all the way through to the other side
  length: length of the peg

class WedgeParameters
  shape: Wedge Shape
  depth: Numeric # depth of the wedge cut, note could be different than length of wedge
  width_axis: Direction3D # wedges run along this axis, so the, so when looking perpendicular to this and the length axis, you see the the trapezoidal "sides" of the wedges
  positions: [Numeric] # positions from center of the timber in the width axis
  expand_mortise: Numeric # amount to fan out the bottom of the mortise to fit the wedges, so 0 means straight sides, and X means expand both sides of the mortise bottom by X (total) from straight. 0 by default



:: 12/30/2025 joint accesorry notes

### PEGS
pegs (could be round or rectangular), rectangular pegs can be inserted at an angle
class RoundPeg
class RectangularPeg:
    size1: Numeric # consistent rule of which axis this is w.r.t to the tenon timber
    size2: Numeric # consistent rule of which axis this is w.r.t to the tenon timber
    rotation: angle in degrees # clockwise rotation when looking at the peg from the insertion side
pegs are always orthogonal to the length axis of the 2 timbers, but they can go in from either side, specified 


QUESTION how to handle peg orientation. do we allow rotating in all idrections? should we make a separat function for tusk tenon  which may want the tenon running lengthwise with the mrotise timber

ANSWER: most generic version is that peg is defined somewhere in the tenon timber, lets oriented in the length axis by default. and then an orientation is applied...

SOLUTION: make a peg class with helpers...

class Peg:
  # peg is always stored in local space of a timber, so identity orientation has peg pointing in the same direction as the length axis of the timber (with the insertion end at the bottom)
  orientation: orientation
  position: V3
  size: Numeric
  shape: square|round 

class PegShape
  size
  shape

create_peg_going_into_face(timber: Timber, face: TimberLongFace, distance_from_bot: Numeric, distance_from_centerline: Numeric, peg_shape : PegShape)


## wedges
wedges are little triangle (with tip cut) pieces of wood going into the tenon end to wedge it in place. 

class wedge:
  # in local space fo the timber, a identity orientation has the point end of the wedge going in the length direction of the timber. 
  # the profile of the wedge (which looks like a triangle with the tip cut off) in the Y axis. Thus thickness is in the y axis
  # teh width of the wedge is in the X axis
  # the 0,0 point of the wedge is at the bottom center of the longer side of the triangle

  +z
   _
  / \
 /   \
/_____\ +x
   ↑
   origin


  orientation: ORientation
  position: V3
  base_width: Numeric
  tip_width: numeric
  thickness: Numeric
  length: Numeric # from base to tip of cut off triangle
  def width() # property alias for base_width


class WedgeShape:
  base_width
  tip_width
  thickness
  length

create_wedge_in_timber_end(timber, end, position, shape: WedgeShape)








:: 12/24/2025 reorg code notes


all core code should live in a "code_goes_here" folder
tests should exists side by side to code (not in their separate test folder)

-timber.py cotains all enums constants and types
-construction.py contains all our timber creation functions
-basic_joints.py contains all basic joint creation functions
-giraffe.py imports all files and rexports them together

don't touch fusion360, rhino, examples, oldcrap folder for now



:: documentation

-installation
-quick start 
-simple reference
  -simple examples of how to use each method with default parameters (axis aligned, face parallel only)
  -ALWAYS use Sympy types
-terminology
  -detailed examples explaing all cnocepts
-advanced reference
  -detailed examples outlining every parameter
-appendix shit


:: TODO

-consider adding "Thing" base class, that has position and orientation 
-do mortise and tenno joint
-add timber metadata 
DONE/SORTA-do the big useless test cleanup

-double check floats again, are floats really necessary? I mean they really aren't
  -at least add a warning if floats are passed in.. I don't think we're ever forced to convert to float ever....
-cleanup render utilities, some of them seem unecessary

-M1 (reward is reimburse H2D LOL)
  DONE-address TODOS in join_timbers
  DONE-create a split timber method that takes a timebr and returns 2 timbers (you splice joint themy ourself later)
  DONE-consider making a better way to store TimberWithJoints and joints class etc...
    DONE-fix tenon joint class
    DONE-add resultant length function after applying joints computerLength(timebr, [joints])
      -get fusino 360 to render just at the rusultant length 
  DONE-add helper render functions
    DONE-extend timbers so joint can be diffed out of it (rather than bool in a long timber, just use an extra long timber when creating the original timber)
    DONE-generic boolean geometry classes
    DONE-use boolean geometery to create negative of tenon cutout timber - (timber - tenon - shoulderplane)
      FAIL-calll this method tenon cutter :D
  DONE-simple joints
    DONE-basic_corner_joint
    DONE-basic_butt_joint
    DONE-basic_splice_joint
    DONE-basic_miter_joint
  DONE-cross_joints
    DONE-basic_house_joint
    DONE-basic_cross_lap_joint

  -butt joints
    -mortise and tenon with pegs and end wedges (generic functon, not intended to be called directly) (supports N pegs)
      -mortise and tenon
      -through mortise and tenon
      -wedged mortise and tenon
      -wedged through mortise and tenon
      -fox wedge mortise and tenon
      -draw bore mortise and tenon
      -Hōzo-zashi Komisen-dome (ほぞ差し込み栓止め)
        -same as draw bore but with komisen peg,
      -tusked mortise and tenon

  -corner joints
    -end_mortise_and_tenon (opitonally extends the mortising timber and offsets the tenon)
      -otherwise calls into mortise_and_tenon above
      -also needs to convert the mortise into an "end cut"
    -half_lap (special case of mortise and tenon? nah, special case of bridle joint? nah)
    -bridle joint (special case of mortise and tenon? nah)
    -maybe try the fancy  one we used on the shed

  -make shed example (just add joints)

  -splice_joint
    -pick a cute one from the book... maybe a gooseneck? (cuz we need it for the double dildo splice joint where we messed up)
  
  -get rhino rendering working for the following joints ...
  -improve examples
    -create series of examples showcasing each feature
    -create series of more complex examples
    -create test runner for examples so the exmaples are also tests :O
    -agent prompt examples
  -template project
  -update docs
    -cleanup README
      -clean up venv/makefile/setup nonsense so its simpler...
    -cleanup comments in code and delete morenotes.md
    -generate docs
    - you need a better way to specify timber lenghts... most of the time you don't really care? It should be determined by the joint in most cases.
      - so I guess joints will resize the timber, even tusk tenon joints take a tusk length parameter, tenon joints have a tenon depth parameter etc.. 
      - i think this is how it already is, update the README to explain this
    - move joint section from morenotes into concepts.md and then delete morenotes

-M2
  -IFC rendering?
  -add panel/board support 
  -update shed example to include panels
  -more joints
    -splice joints
      -TODO 
    -end joints
      -mortise and tenon end joint (calls mortise and tenon but positions the tenon in away from the end)
      -half lap
    -cross joints
      -single notch
      -double notch
    -fancy joints
      -the one where 2 beams butt up against 1 post and have the thing that passes through them




-M3 
  -assembly solver thing :D (or at least define assembly vectors)






:: FUTURE shit
-should I make a "block" class that parents "Timber" and then make a "board" class?
-should we attach meta info to Timbers, it would be nice if timbers were aware of their location on the footprint to assist in finding reference faces for joint operations
- add nominal_size sup port for square and line rule desgins
- make really awesome examples that showcase each parameter of each function



:: TODONE
DONE-add units construction
DONE-sympy stuff
  DONE-fix fuzzy equal comparison function to use the .equals function. If it returns None then you probbaly do need epsilon test thingy...
  DONE/IGNORE-ask if we can add assumptions anywhere
  DONE-keep geometries as geometries for as data for as possible before converting to expression
DONE-make sure freecad rendering works
DONE-make sure oscar shed rafter pocket works
IGNORE-add some more tests for cross lap joint
DONE-address TODOs is smiple mrotise and sitance 
IGNORE-remove LongEdge 
DONE-update tests to not use floats ever (maybe have a couple float tests in a separate file though)
DONE-rework joint classes
DONE-maybe split griaffe sad :(
DONE-rename "End joint" it's not what you think it's actulaly a splice joint, I think you should call them corner joints instead?
DONE-fix name usage consistence, name should nto be in CutTimebr just use timber name
  -also add name to ctor of timber init function
DONE-check for mutabel data 
DONE-remove mutable position/name stuff from examples and oscarshed
DONE-update all warnings to use warning.warn
DONE-prefix timber methods with _in_local_space (meaning orientation and translation not applied)
DONE-cleanup the epsilon constant stuff (when to use flot vs rational for this?? think baotu ti ab it...)
DONE-change giraffe to use render_timber_with_cuts_csg rather than do it itself
DONE-fix the venv stuff in readme, aeither add venv or get rid of it from readme.
DONE-maybe get rid of corner joint
DONE-fix prism cut rendering stuff for housing join,t noe of the transforms is wrong or fusino 360 is busted
  -specifically, when cutting teh housed timber from the housing timber, the housed timber prism isn't getting positioned right. Is this happening in fusion 360 (probbaly) or in giraffe code?
    -it's definitely a fusion 360 issue

DONE-rename FootprintLocation to footprint location Type
DONE- getInside/OutsideFace(timber, footprint)
DNOE- getFacingFace(tiber, direction)
IGNORE- create readme
DONE- cleaunp morenotes (maybe delete it, all comments should be in code)
DONE- start working on docs
DONE- axis aligned timbers
DONE- rename face aligned to face parallel timebers
DONE- 2 faces can be oriented (same normals) or opposing (opposite normals)
DONE-rename "width vector" to "plus_x_width_vector" or "plus_x_width_vector_of_created_timber"
DONE-add helper asserts that does symbolic check if ratinoal otherwise fuzzy
  -check_parallel,perpendicular
DONE- note down default orientation of timbers when created in vertical and horizontal position
  - when laying horizontal, the orientation should always be consistent such that either the width or height of the timber runs in the Z axis direction
DONE/IGNORE- update timber join functions to only care about timber axis vs faces (X/widhth axis, and Y/height axis)

IGNORE- update timebr sizing notes so its really clear which size is which axis
DONE- decide on default orientation for horizontal timebrs
DONE- decide on default orinatiton for vertical timebrs on footprint
IGNORE- update join_timber to  only take axis to align with up/down rather tha face (I guess you can add a flip180 optional parameter....)
IGNORE- cerate join_timebr_raw that takes a raw face normal 
IGNORE- you need a better system for determining timber orientation after each timber creation operation, have sensible defaults 
  IGNORE- when joining 2 vertical timberss top face always faces up by default
  IGNORE- when joniing 2 horizontal timbers, top face laways faces?
  IGNORE- can you throw in a footprint to control which side top fac faces??



:: END TODONE


::12/2025 BREP CUTTING OPERATIONS

make a generic B-rep cutting operations for doing most joints:

-very basic
  -shoulder plane 
    -specified by a position and a normal (infintie plane)
    -created relative to a timber end + direction
  -rectangular prism
    -easy for tenon ends
    -for mortises, do we use the joining timber to locate? Probably not,



Challenges:
- locating rectangular prisms from tenon and mortises
- infinet to finite bounds



:: 12/2025 timber joint rep and  timber length calculatino notes

-cut
  -substractive operation on timber
  -end cuts "set" the length of the timber (either extending it or shortening it) on the end it cut
    -ALTERNATIVE 
      -cut does not care, just does substractive cut. (this is kinda nice)
      -add suppor for infinite timbers (this is really nice)
      -unjointed end cuts can either 
        -be non infinte timber ends (a little ad-hoc)
        -we could use an end cut operation to size the timber (pro) (cumbersome, but most elegant)
  -if cutting on the bot (origin) end, the origin remains in the same place, so the final cut timber has a bottom point below 0
    -ALTERNATIVE: move origin to the very bottom always (ick?)

DECISION
  -timbers defined as is (with origin and length)
  -when a timber has a cut at the end, it becomes infinite in that direction
  -if it helps, you can think of timbers without an end cut as an infinite timber with a default end cut at the length
  
-joint
  -cuts on 1 ore more timbers that connect them


-Cut 
  -implementation detail (sorta)
  -happen at the CSG/brep level
  -if we do the extension thing
    -extending timber end includes cut
    -I guess could/should be used to infer timber length if we go with the "extension" method
  -TODO how are cuts defined, relative to timber origin or relative to a point/face on the timber?
    -maybe relative to timber, in which case a Cut class on its own is meaningless, maybe was well define TimberCut and then [TimberCut] for a list of cuts on a timber (at which point maybe just name it Cut)
-TimberCut
  -A timber with a series of Cuts on it
  -if we do the extension thing
    -has some face-cognition, meaning cuts happen relative to a face,  (this actualy only need)
      -only ends can be "extended", this is very much an ad-hoc operation
-Joint
  -a list of TimberCuts that form the joint
  -also includes joint accesories like draw bore,s fasteners, etc
-CutTimber
  -A timber with a list of TimberCuts?  


:: 11/2025 Reference Stuff

we want to introduce some kind of notion of "ReferencePoint/Line/Plane" for the purpose of positioning timbers relative to each other.
We'll call these classes "ReferenceFeature" 

For example:

I want to create 3 timbers like so:

      
      |
A-----|
  |   |
  |   |
  B   C  


so in this case, we want to use `join_timbers` and align it such that:
- the top face of timber A align with the top face of timber B
- the vertical position set above determines where it will connect with timber C



In general, we want to be able to take a ReferencePoint/Line/Plane of a timber and position that relative to another ReferencePoint/Line/Plane of a timber

We support the following ReferencePoint/Line/Plane of a timber

Timber Vertex  -> ReferencePoint
Timber Edge -> ReferenceLine
Timber Face -> ReferencePlane
Timber Centerline -> ReferenceLine
Timber Face + Timber Centerline -> ReferencePoint



Lets look at the current signature of join_timbers:

def join_timbers(timber1: Timber, timber2: Timber, 
                location_on_timber1: float,
                location_on_timber2: Optional[float] = None,
                lateral_offset: float = Integer(0),
                stickout: Stickout = None,  # Defaults to Stickout.nostickout()
                size: Optional[V2] = None,
                orientation_width_vector: Optional[Direction3D] = None) -> Timber:

In this case we want to be able to do the general positioning instead of just location_on_timber1

There are some limitations since we only have 1 DOF for positioning, in particular we must position against either the Reference Plane that is the top or bottom Face of timber1
In this case, the ReferenceFeature of Timber1 also carries an implicit direction argument, but perhaps we may as well imbue Reference Features with a direction vector? The direction vector must always be perpendicular to the line/plane. 
By convention, the directional vector coming out of an vertex/edge will be perpendicular to one of the faces that the vertex/edge lives on

For the ReferenceFeature of the created timber, it could be:

ReferencePoint
ReferenceLine/Plane that is parallel with ReferencePlane of timber 1




:: 11/2025 DONE Stickout

by default, join timbers joins between midline of timbers but often we want to join from the outside, so we should add modes to the stickout class like

stickoutReference1 / stickoutReference2

enum StickoutReference = CENTER_LINE | INSIDE | OUTSIDE


CENTER_LINE
joined timber
| |
||===== createdtimber
| |

INSIDE
joined timber
| |
| |===== createdtimber
| |

OUTSIDE
joined timber
| |
|====== createdtimber
| |


Also we should probbal yrename join_timbers to refere to timber1/2 as timberA/B instead