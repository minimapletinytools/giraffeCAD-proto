

:: 1/23/2026 viewer planning notes

use three.js to implement viewer as a VScode plugin

base features:
-vscode integration (must be easy to use and integrate with some main script)
-render all timbers
-3d space navigation
-click on timber to focus and see more details
  -render gimbal to show local coordinates

additional features:
-incremental rerendering upon refresh
-timber/folder hierarchy (show/hide/collapse)
-hover over focused timber individual fetaures 
-feature rendering (e.g. render a face in a different color, render joint cuts in different color, etc)

future features:
-2d/3d drawing generation and view (add mesaurements to )
  -a good step 1 would be to show some basic measurements when focused on 1 timber
-assembly explosion


major decision points and things you'll probably need
-triangulation in python or js  (probably in js)
-CSG to mesh function
-add metadata to timbers
-add metadata to CSG/joints for features
  -this includes naming cuts and sub cuts like faces of a prism
  -TODO you probably need some feature CSG classes and then learn to intersect them for new features...
  -TODO this needs to be its own spec

for the naive version of feature highlighting:
  -CSG metadata maps to feature filter functions so that we can do the following
    -you probbaly need some kinda BVH to do this efficiently, but linear search is fine too LOL
  -hover -> raycast triangle -> find feature on timber

:: 1/23/2026 viewer and drawing notes [messy]

We want to be able to generate 2d/3d drawings and be able to highlight features in the viewer.

so the key thing we need is to be able to identify features on timbers. Thihhs comes in 2 flavors
1. when generating diagrams, it needs a list of features to create drawings from
2. when in the viewer, it needs to raycast to see which featuer your hovering over.

2. is more or less covered by 1, perhaps we need some additional data to deal with priorities or something but it should nto be a big deal.

For features when generating drawings, lets worok through some broad examples:

-round draw bore holes need their centers and diameters marked
-mortise holes need their dimensions and depth marked
-angled things can have lengths projected onto axis and/OR show actual angle
-only 1 side of parallel lines of rectangles need to be marked
-view from multiple isometric angles, each measurement need only be drawn once (do this automatically or allow user to specify which measurement goes to which view)
-measurements are specified to some reference point
  -you could auto pick reference point and ensure all referenced points can be referenced to face/edge on the timber I guess?
  -or allow user to specify which feature to reference to in the drawing
-automatic marking generation will probbaly make too many marking so maybe remove some?
-I think in general we need to make suer all features are solveable, have priority on some fetaures, 
  -but prehaps we just name some featuers and do due diligence in coding to ensure everything else is solveable

examples of features we want to mark:

-distance between 2 parallel faces
  -choose side perpendicular to these 2 faces to draw on (or with smallest dot product)


-special rules for face aligned features:
TODO


specific examples:

-mortise example:
  -mortise width and height (distance between opposing parallel faces of the mortise)
    -pick a view to draw it, either top or side, but not from the ends (could use priority system to determine which face of the timber to mark on?)
  -morties depth
    -distance between morties shoulder face and mortise bottom
  -mortise shoulder
    -side view only, distance between mortise shoulder face and timber face that the morties is on 
  -mortise position
    -distance from one side of the mortise to timber face
    -distance from one side of the mortise to the timber end (need rule to pick side, I guess just pick the closest?)
    -(HARD) if multiple mrotises in a row on a timber we may want to do interval spacing (from center) or side to side on the mortises
    -if rotated on face normal axis, mortise, then do a corner of the mortise + angles I guess?
    -if rotated on another axis then mortise depth is measured from 1 side of the 
  

So we need to design a way to 
1. mark features with names 




:: 1/6/2026 metadata

-timber metadata 
  -material
  -reference face(s) 
    -used for generating drawings

-joint metadata
  -assembly order
  -assembly DOF
    -by combining order and DOF you can validate if it's possible to assemble


we want to generaize name/parent so we can build ahirerachy, 
there is one special distiction which is that there are Construction and Concept names, Construction maps to actual objects or are used to organize actual objects. Concepts map to things like joints and features

I guess for now just mash them all together but flag them as such. when rendering in something that doesn't support concepts, just omit them, or we can extract concepts into a sepaarte tree but use the same hierarchy (if they were parented to a construction, then just create ap roxy for the construction in the concept tree)


class TicketType(Enum):
  Folder
  Timber
  Accessory
  Board
  Joint
  etc

class Ticket
  name
  parent
  type: TicketType
  def is_type()
  def is_concept()
  def is_construction()

:: 1/11/2026 advancedtimber class

class PerfectTimberWithin
  current timber stuff
  nominal_bounding_box 
  get_perfect_timber_within_CSG
  get_actual_csg -> CSG (make mesh a CSG class that errors if in a union or on the RHS of a difference)
  is_perfect_timber: check nominal_bounding_box is same as true box, only works if is timber

Timber

Board
  add board related measuring functions here?


MeshTimber
RoundTimber
PolyTimber
CSGTimber?
    




:: documentation

-installation
-quick start 
-simple reference
  -simple examples of how to use each method with default parameters (axis aligned, face parallel only)
  -ALWAYS use Sympy types
-terminology
  -detailed examples explaing all cnocepts
-advanced reference
  -detailed examples outlining every parameter (generate from python files)
-appendix shit


:: TODO

DONE-all methods have a property `as` that returns TimberFeature 
  -TimberFeature has methods `face` `reference_end` `long_face` etc 
  -so you do long_face.as.face() to do your enum castings
DONE-MeasuredTimberFeature -> MarkedTimberFeature
DONE-swap measure/mark
DONE-move out all the get_ methods in Timber.py (change into mark functions)
DONE-be consistent about get/find usage
  -get -> use when you might do an "@property" but we don't get properties so use get, virtually no computation
  -find -> requries some computation
DONE-don't forget to rename class methods in timber.py
DONE-move 
  DONE-more  the helper shit in joint_shavings to  timber_shavings unless I guess if it's really super specific to joints...
  DONE-move TODO stuff in timber into timber shavings
DONE-delete deprecated stuff in joint_shavings and replace with measuring function
DONE-get rid of CSGCut and HalfSpace CSG... omg
DONE-address TODOs in joint_shavings.py
DONE-get rid of extra long edge enums... we don't orient there..
DONE-add short edges to the enum
DONE-maybe revisit measuring naming conevntion
  -we have situations where we want to scribe (multiple timbers) but work with a feature not a distance i.e. mark_closest_point_on_centerlines
  -maybe measurements should be wrapped in an object?.... then you can just measure_face().mark() and then you would do mark_into_face().measure_from_face().distance
  -and i guess then scribe means taking multiple things to one measurement and could by polymorphic to take either local measurements or global features 
  -and we would still need something that takes multiple things to one marking (that marking might not hvae an analgous measure so we can't just scribe().mark())
  -or jsut have scribe return markings that you need to measure... that's probably better... and get rid of the current scribe functions you have...
    -it's just annoying to measure cuz then you need to specify the reference end... but I guess that's a good thing as there fewer args to the mark function!
DONE-swap measure and mark

-make examples of how to use measure/mark to set parameters in cutting functions
-maybe just have Joints returns their final size rather than try to calculate it....


-add timber size estimation function (really you want a prism BB)
  -then add frame size estimation function
-Mitered and keyed lap joint  (箱相欠き車知栓仕口 Hako-aikaki-shachi-sen-shikuchi) using new measuring functions
-update morties and tenon to support
  -perpendicular but not face aligned
  -not perpendicular but partially face aligned (for braces)
    -maybe have an add brace function?
  -neither perpendicular nor face aligned
DONE-think about how you want to make example selector and make it future proof or useful as reference
  -(example metadata, (V3) -> Frame)
-do better testing on join_perpendicular_on_face_parallel_timbers to make sure it's right....

-be consistent about function local/golbal naming
  -local input vars should have the suffix  _local
    -some things must be interpreted locally such as "face" or "distance", these d onot have the suffix
  -functions return things in golbal space by default unless _local suffix

-is there some way to make orientation/direction generic more like a measuring function?

-make timber names mandatory and if not provided a random one is generated.
-BUG Joint uses a dictionary of names to cuts but timber names are not guaranteed to be unique!

RENAME
DONE-cleanup where to put get_point_on_face and project_point_onto_face
  -probably move these into timber_shavings or something
DONE-CutCSG -> PotatoCSG
  -or CutCSG probably better...
DONE-Moothymoth -> Rule?
-type alias SomeTimberFace = Union[TimberFace, TimberReferenceEnd, TimberLongFace]
-come up with joint naming rules, in particular if _on_face_aligned_timbers sholud be used or not
  -oFAT on face aligned timbers
  -oFAACaT on face aligned coaxial timbers
  -oPT on plane aligned timbers (one pair of faces are parallel)
  -oPT on parallel timbers
  -oOT on orthognal timbers
-do the horseCAD rename
  -change cut_ to layout_? or plan_?
  -rename create_timber to hew?
    -make sure to rename the ones in helperonis as well
    -then boards/panels can be mill_board
    -what about join/stretch/split?
      -join -> glue?
  -add from_joints -> raise function to Frame
    -have an on class member version of it to cuz its cutre that way
  -oscar shed -> tiny snack house
  -horsey viewer -> horse watcher or barn raising?
-consider doing a rename pass on validitiy checkers  
  -assert
  -check
  -is
  -does
  -contains (specific to cutcsg...)
  -are



EXEMPLIFY
-create all_joints.py 
  -exports all joints
-create potato_joints.py and potato_joints_examples.py
  -pass in sensible default parameters for all joints
-examplify 
  DONE-create some map of example name to example function map so you can dynamiaclly get to all examples
  -would be cool do deep link by into functions/docs in the future...



  
-3 major features
  -measure functions
  -refactor timber class
  -add timber metadata
    -prepare for CSG metadata as well...

-pull out parts of mortise and tenon function, maybe move to joint_helperonis.py in particular
  -round peg support
  -peg positioning
  -finding the shoulder point/shoulder plane


-M1 (reward is reimburse H2D LOL)
  DONE-address TODOS in join_timbers
  DONE-create a split timber method that takes a timebr and returns 2 timbers (you splice joint themy ourself later)
  DONE-consider making a better way to store TimberWithJoints and joints class etc...
    DONE-fix tenon joint class
    DONE-add resultant length function after applying joints computerLength(timebr, [joints])
      -get fusino 360 to render just at the rusultant length 
  DONE-add helper render functions
    DONE-extend timbers so joint can be diffed out of it (rather than bool in a long timber, just use an extra long timber when creating the original timber)
    DONE-generic boolean geometry classes
    DONE-use boolean geometery to create negative of tenon cutout timber - (timber - tenon - shoulderplane)
      FAIL-calll this method tenon cutter :D
  DONE-simple joints
    DONE-basic_corner_joint
    DONE-basic_butt_joint
    DONE-basic_splice_joint
    DONE-basic_miter_joint
  DONE-cross_joints
    DONE-basic_house_joint
    DONE-basic_cross_lap_joint
  DONE-splice_joint
    DONE-gooseneck joint 
    DONE-pick a cute one from the book... maybe a gooseneck? (cuz we need it for the double dildo splice joint where we messed up)
  -butt joints
    DONE-mortise and tenon with pegs and end wedges (generic functon, not intended to be called directly) (supports N pegs)
      DONE-mortise and tenon
      DONE-draw bore mortise and tenon
      DONE-through mortise and tenon
      DONE-add offset mortise peg param (so that it tightens the joint up)
    -dovetail lap joint (for the floor joists)
  -corner joints
    -maybe try the fancy  one we used on the shed  Mitered and keyed lap joint  (箱相欠き車知栓仕口 Hako-aikaki-shachi-sen-shikuchi)

  -decorative cuts
    -basically joints with 1 timber
    -you'll need to add curve CSG D:
  -make shed example (just add joints)

  -improve examples
    -create series of examples showcasing each feature
    -create series of more complex examples
    -create test runner for examples so the exmaples are also tests :O
    -agent prompt examples
    -make sawhores example nice (eh, maybe you need to wedged dovetail mortise and tenons... or nuki joints or whatever)
  -template project
  -update docs
    -cleanup README
      -clean up venv/makefile/setup nonsense so its simpler...
    -cleanup comments in code and delete morenotes.md
    -generate docs
    - you need a better way to specify timber lenghts... most of the time you don't really care? It should be determined by the joint in most cases.
      - so I guess joints will resize the timber, even tusk tenon joints take a tusk length parameter, tenon joints have a tenon depth parameter etc.. 
      - i think this is how it already is, update the README to explain this
    - move joint section from morenotes into concepts.md and then delete morenotes

-M1.5
  -add more features to mortise and tenon joint
    -extract out peg creation stuff, it will be useful in other places
      -basically, just figure out the start point and direction of the peg... it will return to you a tuple of prisms to substract from the mortise and tenon timber, and a peg accessory
    -support non face aligned cases
      -clean up the mortise shoulder calculation shit wtf or maybe yo uneed it for non face aligned cases?
    -end wedged mortise and tenon
    -fox wedge mortise and tenon
    -Hōzo-zashi Komisen-dome (ほぞ差し込み栓止め)
      -same as draw bore but with komisen peg,
    -tusked mortise and tenon
    -support tenon_rotation
    -support mortise_shoulder
    IGNORE-add additinoal mortise timbers to mortise tenon joint.. so you can do the thing like the stacked joint on the back post of oscarshed
      -actually better to do this as a house joint and 2 separate mortise and tenon joints. the second mortise and tenon joint will be awkard but it works so why not
    -end_mortise_and_tenon (opitonally extends the mortising timber and offsets the tenon)
      -otherwise calls into mortise_and_tenon above
      -also needs to convert the mortise into an "end cut"
  -basic joints, or maybe move these to "lap joints" file?
    -half_lap (use same code as cross lap joint?)
    -bridle joint (special case of mortise and tenon? nah)
  -sidewedged dovetail mortise and tenon joint (this method is its own method)
  -a few more fancy ones from here https://architizer.com/blog/inspiration/industry/japanese-art-of-wood-joinery/

-M2
  -IFC rendering?
  -add panel/board support 
  -update shed example to include panels
  -more joints
    -splice joints
      -TODO 
    -coner joints
      -mortise and tenon end joint (calls mortise and tenon but positions the tenon in away from the end)
      -half lap
    -cross joints
      -double notch
    -fancy joints
      -the one where 2 beams butt up against 1 post and have the thing that passes through them
  -add screw joint
  -chamfer render support?
  -add stl support for joint accessories so you can use framing hardware
  -define assembly directions for each joint (does this go in meta data?)
  -assembly solver thing :D (lol no) 






:: FUTURE shit
-should I make a "block" class that parents "Timber" and then make a "board" class?
-should we attach meta info to Timbers, it would be nice if timbers were aware of their location on the footprint to assist in finding reference faces for joint operations
- add nominal_size sup port for square and line rule desgins
- make really awesome examples that showcase each parameter of each function



:: TODONE

IGNORE-transform prob does not need to be frozen...
DONE-come up with consisten import scheme....
  DONE-maybe rename Union to avoid confilct...
DONE-see if you can get rid of FaceAlignedJoinedTimberOffset with a measuring function
  DONE-implementation
  DONE?-do better testing 
DONE-double dildo joint seems to broken in fusion 360
  DONE-fusion 360 broken in general...
DONE-dovetail lap joint
DONE-allow extrude polygon to extrude in both directions
DONE-change joint cut_timbers: Tuple[CutTimber, ...] into a map so you can reference joint pieces by name rather than index
DONE-add back post joints to oscar shed
DONE-delete rhino for now
IGNORE-update fusino 360 to similar as run_examples
DONE-Update Frame to be built from joints
DONE-be consistent about V2 vs (Numeric,Numeric) tuple
DONE-I tihnk the pointing constants in rule are wrong (the comments are certainly wrong)
DONE-fix morties_and_tenon_joint_example
DONE-pull out logic into joint_helperonis.py
  -split the lap helper to do the lap cut on just 1 timber...
IGNORE-add optional key to lap helper?
DONE-gooseneck lap joint
DONE-change gooseneck to return 2 Convex CSGs or support non convex polygon extrusion CSG (errors on some functions or returns None or whatever)
DONE-rafters get added twice in oscar shed
DONE-add extrude polygon csg rendering to fusino 360
DONE-fix the 13:43:54  /Users/peter.lu/kitchen/faucet/giraffeCAD-proto/code_goes_here/japanese_joints.py:221: UserWarning: Gooseneck joint configuration may not be sensible: Joint ends are pointing in the same direction (dot product = 1.000). For a splice joint, the ends should point in opposite directions (dot product should be -1) warning
DONE-do irrational joint test for rendering
DONE/IGNORE-static method in orientation class
DONE-fix or delete goosenecksplice example in japanese joints examples
DONE-do refactors in timber as well...
DONE-REFACTOR TIME
  DONE-create Transform class in rule
  DONE-rename helperonis to something more cute
  IGNORE-make global/local var naming consistent
    DONE-add cursor rules for this
  DONE-update places to use teh local/global stuff in Transform class


DONE-cleanup
  DONE-make it clear dircetion3d and V3 are the same, and get rid of uncessary conversions...
  DONE-rename BACK to BACKWARD (DONE: renamed FORWARD to FRONT instead for consistency)
  DONE-clean up rule tests to not use exact euality...
IGNORE-get rhino rendering working for the following joints ...
DONE-see if you can fix the transform issue in fusion360...  should be able to do as rigid joint with origin
  FAIL-in fusion 360, hwen transforming occurences (components) to their final position.. rather than setting transform2. instead can you create a rigid joint with the global origin to set the position instead. 
  DONE-just do the body move way...
DONE-freecad
  DONE-clean up the run_ freecad stuff so it's more consist and easy to switch between examples
  DONE-add accesory rendering to freecad
DONE-add basic extrude profiles to CSG
DONE-update oscar shed to use mortise and tenon joint
DONE-mortise hole calculation is incorrect please fix
DONE-add Frame class to timber.py 
  -add a check_no_floats method that checks that all the contents of the frame are using sympy rationals, NO FLOATS
  -assert on the check_no_floats method in the ctor to ensure no floats are in the frame
  -update all examples to output frames
  -update fusino360 and freecad to take a frame object
  -get rid of PartiallyCutTimber class while you're at it
DONE-rewrite all joint tests, they are all kinda messed up tbh
  DONE-miter joints
    -uncomment test when get_end_position is fixed
  DONE-just delete get_end_position and the minimal_boundary thing.
  DONE-splice joints
    -delete test relying on get_end_position
  DONE-house joint
    -add test using contains_point
  DONE-cut_basic_cross_lap_joint
    -TODO

DONE-improve tests
  DONE-fix is_point_on_boundary, it's not working... maybe add some tests for it...
  DONE-buttjoints
    IGNORE-fix nearest_point_on_face_to_point_global and uncomment the test
  DONE-mortise and tenon joint
    DONE-fix the T shape orientatin, it's all fucked up right now 
    DONE-peg forward_length / stickout depth tests
    DONE-peg_depth = none case, ensure it's picking the right axis to use for computing peg depth
    DONE-peg orientation should be perpendicular to tenon timber
    DONE-test points in peg hole do not line in timber/mortise csg
    DONE-test points in peg hole do lie on the peg CSG
    DONE-test mortise depth and tenon depth using CSG test functions

  
DONE/SORTA-do the big useless test cleanup
IGNORE-cleanup render utilities, some of them seem unecessary
DONE-rule
  DONE-cleanup all the static ctor stuff, it's confusing
  DONE-create new set of orientation constants for doing timber orientation
    -facing_west/east/north/south (horizontal timbers, top face up, Z-axis rotations)
    -pointing_up/down (identity and 180° Y rotation)
    -pointing_forward/backward/left/right (vertical timbers, +X→+Z, Z-axis rotations)
      -facing_west and pointing_up are both identity orientation
      -all documented with clear canonical conventions
DONE-do mortise and tenon joint
  DONE-fix peg holes in mortise not going all the way through
  DONE-fix default peg size or whatever (maybe jsut udpate eaxmple)
DONE-fix peg rendering with wrong sides ticking out...
DONE-joint rendering
  DONE-add csg function to accessoiers
  -clean up accesory rendering in fusino360
  
DONE-add units construction
DONE-sympy stuff
  DONE-fix fuzzy equal comparison function to use the .equals function. If it returns None then you probbaly do need epsilon test thingy...
  DONE/IGNORE-ask if we can add assumptions anywhere
  DONE-keep geometries as geometries for as data for as possible before converting to expression
DONE-make sure freecad rendering works
DONE-make sure oscar shed rafter pocket works
IGNORE-add some more tests for cross lap joint
DONE-address TODOs is smiple mrotise and sitance 
IGNORE-remove LongEdge 
DONE-update tests to not use floats ever (maybe have a couple float tests in a separate file though)
DONE-rework joint classes
DONE-maybe split griaffe sad :(
DONE-rename "End joint" it's not what you think it's actulaly a splice joint, I think you should call them corner joints instead?
DONE-fix name usage consistence, name should nto be in CutTimebr just use timber name
  -also add name to ctor of timber init function
DONE-check for mutabel data 
DONE-remove mutable position/name stuff from examples and oscarshed
DONE-update all warnings to use warning.warn
DONE-prefix timber methods with _in_local_space (meaning orientation and translation not applied)
DONE-cleanup the epsilon constant stuff (when to use flot vs rational for this?? think baotu ti ab it...)
DONE-change giraffe to use render_timber_with_cuts_csg rather than do it itself
DONE-fix the venv stuff in readme, aeither add venv or get rid of it from readme.
DONE-maybe get rid of corner joint
DONE-fix prism cut rendering stuff for housing join,t noe of the transforms is wrong or fusino 360 is busted
  -specifically, when cutting teh housed timber from the housing timber, the housed timber prism isn't getting positioned right. Is this happening in fusion 360 (probbaly) or in giraffe code?
    -it's definitely a fusion 360 issue

DONE-rename FootprintLocation to footprint location Type
DONE- getInside/OutsideFace(timber, footprint)
DNOE- getFacingFace(tiber, direction)
IGNORE- create readme
DONE- cleaunp morenotes (maybe delete it, all comments should be in code)
DONE- start working on docs
DONE- axis aligned timbers
DONE- rename face aligned to face parallel timebers
DONE- 2 faces can be oriented (same normals) or opposing (opposite normals)
DONE-rename "width vector" to "plus_x_width_vector" or "plus_x_width_vector_of_created_timber"
DONE-add helper asserts that does symbolic check if ratinoal otherwise fuzzy
  -check_parallel,perpendicular
DONE- note down default orientation of timbers when created in vertical and horizontal position
  - when laying horizontal, the orientation should always be consistent such that either the width or height of the timber runs in the Z axis direction
DONE/IGNORE- update timber join functions to only care about timber axis vs faces (X/widhth axis, and Y/height axis)

IGNORE- update timebr sizing notes so its really clear which size is which axis
DONE- decide on default orientation for horizontal timebrs
DONE- decide on default orinatiton for vertical timebrs on footprint
IGNORE- update join_timber to  only take axis to align with up/down rather tha face (I guess you can add a flip180 optional parameter....)
IGNORE- cerate join_timebr_raw that takes a raw face normal 
IGNORE- you need a better system for determining timber orientation after each timber creation operation, have sensible defaults 
  IGNORE- when joining 2 vertical timberss top face always faces up by default
  IGNORE- when joniing 2 horizontal timbers, top face laways faces?
  IGNORE- can you throw in a footprint to control which side top fac faces??



:: END TODONE


:: 1/27 THE BIG SHAVING/MEASURING RENAME

-We need a better system for naming measure/mark, we have scenarios like
  -timber -> feature 
    -MARK
  -timber/feature -> distance
    -MEASURE_FROM
  -timber/feature -> feature
    -MARK_FROM
  -timber -> distance
    -MEASURE
  -timber/timber -> distance
    -MEASURE_BETWEEN
    -gauge?
  -timber/feature/timber/distance -> distance
    -MEASURE_BETWEEN
    -scribe?

So I think the general rule is 
mark -> outputs fetaure that isn't a point 
scribe -> outputs V3? (and not a Point... probably just get rid of Point? or have point be V3 or whatever?)
measure -> outputs distance
??? -> outputs direction
~gauge -> inputs 2 timbers, outputs distance~
~scribe -> inputs 2 timbers, outputs distance~


Or rather
- mark takes measurements in LOCAL space and outputs features in GLOBAL space
- measure takes features in GLOBAL space and outputs measurements relative to (LOCAL) features
- scribe takes features in LOCAL space and outputs features relative to (LOCAL) features

note we have the following

distance: always taken relative to a feature and can be converted to a feature itself
point: a special case of a feature
feature: everything is a feature at the end of the day :O


-prefixes we could use
  -measure
  -mark
  -gauge
  -scribe
  -get
  -find
  -compute
  -calculate
  -adopt (currently just used in adopt_csg which maybe should be changed to scribe_csg?)


:: 1/8/2026 reference dimension helper classes

measuring functions should look like this:

```
measure_from_some_feature(
  timber_to_reference,
  timber_to_mark,
  reference_feature_on_timber_to_reference,
  measurement_relative_to_reference_feature_on_timber_to_reference_local,
) -> measurement_in_timber_to_mark_local_space
```
for example:
```
timber_cross_section_size_from_reference_long_faces(
    timber_to_reference,
    timber_to_mark, 
    x_face: Optional[LongFace]
    y_face: Optional[LongFace]
    size: V2
) -> size_in_timber_to_mark_xy_local_space
# so (x,y) would have x in the x_face axis and/or y in the y_face axis of timber_to_reference
# only valid if these faces are adjacent
# you typically only want to specify 1 of these faces and the other one is inferred but nothing is stopping you from specifying both
```


sometimes we also want to take reference_feature_on_timber_to_mark and in this case, the returned measurement is relative to reference_feature_on_timber_to_mark. Of course this may only make sense in some cases, in particular that the feature in both cases share the same "basis".

let's make sharing the same basis concrete.

We use the feature definition in concepts.md

first declare the feature e.g. some long edge on a timber (we treat edges as infinite lines)
next restrict the basis e.g. measuring on some face (plane) of the timber
at this stage, we need to do some *magic* to determine the sign of the basis, so if we're measuring on a face of some timber from an edge, then positive is obviously measuring away from the edge onto the face.
for multidimensional basis, we always go x -> y -> z in that order
sometimes the reference timber and mark timber share a basis but have different signs, in this case, the measurement is taking in the reference timbers basis, and then returned in the mark timber basis obviously.
sometimes (often) the basis match but the measurements don't overlap in global space, in this case, project the point orthogonally from 1 basis to the other (TODO need to define this more rigorously, basis is insufficient, we are really talking about a distance in space relative to either a line (1D) or a point (2D) in a plane, in which case we can project to another plane that's parallel (or perhaps better to treat it as a plane/line in space that we intersect with another plane? nah)
or we might be takling about a measurement in an axis or plane (for sizes), in which case no project is needed

Here are some example of feature + basis 

-size on face
-distance from long edge on long face
-distance from end face on centerline
-distance from shoulder plane on centerline (this gets converted to distance from end face internally)

examples of things we want to do

-using join timbers, we want to set lateral offest such that the outside face of the created timber is inset from the outside face of the timber to be joined:
  -how do we do this, the created timber doesn't exist yet???
-position a rafter such that the bottom of of the rafter is 1 inch away from top of the beam
  -same issue as above...
-size a tenon


-measure functions
  -decide consistent naming scheme for measure helpers and document
  -some helpers to add (and use throughout)
    -find_closests_face_to_timber_end_direction
    -plane_from_offset_timber_face
    -also ask AI to see if there are any others
      -especially when it comes with all the timber end if statements
  

----------------
CLEANED UP VERSION OF GENERIC MEASURING FUNCTION

SCRIBE functions
in general we want a very generic scribe function
def scribe1D(distance, from_feature, on_timber, to_timber, from_feature_on_to_timber) (you actually need to constrain by a 1/2 DOF for this to work on edges/points)
notable challenges
-directionality of distance may not be intuitive
-how to constrain DOF on points/edges?

!!!!actually what we'd really like is something like

measure(measurement, feature, timber) -> global feature

mark(golbal feature, timber) -> measurement from local feature

:: 1/19/2026 impl methodology and helpre notes

-joint construction methodology
  -I think for most end joints you want to create a transform that defines where to compute all of the joint features from!!!
    -implemnetation detail, add to cursor rules
    -always use the look at convention, so that +x is right, +y is into the timber (looking at the face), +z is in the joint direction, 
  -try and do the same for butt joints? The challenge here is if it's not perpendicular
  -call it marking_transform?
-joint testing methodology
  -can we do something similar with joint testing? typically, we want to find some point on the face of a timber and work inwards to test various points in the joint
    -so in general, we want to create a transform on the timber and pick points relative to there to test
-variable naming methodology
  -ALWAYS prefix vars in global space with _global
  -try to laways prefix vars in local space with _local
  -unprefix vars should usually be in local space

-feature classes?
  -plane 
  -transform_on_timber

 

:: 1/16/2026 cut agent instructions

implement def chop_lap_on_timber_ends(top_lap_timber: Timber, top_lap_timber_end: TimberReferenceEnd, bottom_lap_timber: Timber, bottom_lap_timber_end: TimberReferenceEnd, top_lap_timber_face: TimberFace, lap_length: Numeric, lap_depth: Numeric, top_lap_shoulder_position_from_top_lap_shoulder_timber_end: Numeric) -> (CutCSG, CutCSG):
1. determine the end the top lap timber based on top_lap_shoulder_position_from_top_lap_shoulder_timber_end and lap_length
2. project the end position onto bottom_lap_timber
3. create half plane cuts to remove the end
4. determine the orientation of the lap based on top_lap_timber_face
5. in the axis orthogonal to top_lap_timber_face find where the 2 laps meet based on lap_deth
6. create prisms to remove the material from each timber resp
7. union with the half lap cuts we created earlier and return the CSG pair


implement cut_lapped_dovetail_butt_joint

-there is no lap like the gooseneck joint
-assert that the receiving timber is orthognal
-so the shoulder of the dovetail starts right on the receiving timber and then inset by receiving_timber_shoulder_inset
-create a helper function in joiint_shavings to do the shoulder inset notice, it takes the face to notch, where along the face to notch and how wide (take center and width), how far to inset the shoulder
-the dovetail polygon is a simple trapezoidal shape
-use similar logic as we did on the gooseneck joint to cut the dovetail positive in the tenon timber and then adopt the dovetail CSG into the mortise timber to notch it out.



:: 1/6/2026 timber/board [ARCHIVE]

class hierarchy could look like this:

-thingy (position/orientation, allows converting from local to global coords)
  -block
    -timber
      -MeshTimber
      -RoundTimber
      -PolygonalTimber
    -board
  -joint accessory

-block has faces, but no concept of end/long face
-boards are lie really big stubby timbers, 
  -they have short edges instead of long edges lol.
  -they have sides instead of ends
-boards and timbers have different metadata
-obv, boards and timbers have different joint methods, although their implementations might ultimately be the same and you can use conversion functions if you want to put a timber joint on a board say



:: 1/9/2026 vscode extension 3js viewer

https://chatgpt.com/share/695e878b-da08-800c-a658-6913d1b54ee0

Main challenge:

- allow metadata to be attached to CSG... we want to do this per face which is tricky... as we don't have a good way to identify features in our CSG geometry.... I guess you mainly want "surfaces as result of this difference" or perhaps "surfaces with this normal at this position"

so the next step is acutally to do a CSG expansion

-allow contains_point and boundary to return none, as we will add shapes that can't easily be computed
-allow metadata to be defined on CSG primitives (HARD)
  -primitives define surfaces
  -surfaces must be "preserved" through unions and differences
  -come up with examples to see if this covers our use cases:
    -prism -> timber
    -diff prism -> tenon
    -half plane cut -> shoulder plane
  -would be cool to also mark edges and vertices
-I think the above is doable without embedding info in the meshes, you would just need to have a set of filters (and bounding volumes) to check if some edge/tri matches some feature and we can do this using normals and boundary checks etc
-add CutCSGMesh class and add to_csg_mesh function 
  -hard part, as we also need to add metadata to the mesh
  -I think metadata can be injected based on 


:: 12/30/2025 joint accesorry notes

### PEGS
pegs (could be round or rectangular), rectangular pegs can be inserted at an angle
class RoundPeg
class RectangularPeg:
    size1: Numeric # consistent rule of which axis this is w.r.t to the tenon timber
    size2: Numeric # consistent rule of which axis this is w.r.t to the tenon timber
    rotation: angle in degrees # clockwise rotation when looking at the peg from the insertion side
pegs are always orthogonal to the length axis of the 2 timbers, but they can go in from either side, specified 


QUESTION how to handle peg orientation. do we allow rotating in all idrections? should we make a separat function for tusk tenon  which may want the tenon running lengthwise with the mrotise timber

ANSWER: most generic version is that peg is defined somewhere in the tenon timber, lets oriented in the length axis by default. and then an orientation is applied...

SOLUTION: make a peg class with helpers...

class Peg:
  # peg is always stored in local space of a timber, so identity orientation has peg pointing in the same direction as the length axis of the timber (with the insertion end at the bottom)
  orientation: orientation
  position: V3
  size: Numeric
  shape: square|round 

class PegShape
  size
  shape

create_peg_going_into_face(timber: Timber, face: TimberLongFace, distance_from_bot: Numeric, distance_from_centerline: Numeric, peg_shape : PegShape)


## wedges
wedges are little triangle (with tip cut) pieces of wood going into the tenon end to wedge it in place. 

class wedge:
  # in local space fo the timber, a identity orientation has the point end of the wedge going in the length direction of the timber. 
  # the profile of the wedge (which looks like a triangle with the tip cut off) in the Y axis. Thus thickness is in the y axis
  # teh width of the wedge is in the X axis
  # the 0,0 point of the wedge is at the bottom center of the longer side of the triangle

  +z
   _
  / \
 /   \
/_____\ +x
   ↑
   origin


  orientation: ORientation
  position: V3
  base_width: Numeric
  tip_width: numeric
  thickness: Numeric
  length: Numeric # from base to tip of cut off triangle
  def width() # property alias for base_width


class WedgeShape:
  base_width
  tip_width
  thickness
  length

create_wedge_in_timber_end(timber, end, position, shape: WedgeShape)




:: 12/29/2025 mortise and tenon notes



this function is very generic and does a bunch of things. in particluar we want the following variants which will all call into this function;

      -mortise and tenon
      -through mortise and tenon
      -wedged mortise and tenon
      -wedged through mortise and tenon
      -fox wedge mortise and tenon
      -draw bore mortise and tenon
      -Hōzo-zashi Komisen-dome (ほぞ差し込み栓止め)
        -same as draw bore but with komisen peg,
      -tusked mortise and tenon 


for now, create the super generic 

cut_mortise_and_tenon_many_options_do_not_call_me_directly

then do simple_mortise_and_tenon function that has no pegs or wedges

the cut_mortise_and_tenon_many_options_do_not_call_me_directly function, it should take the following parameters

-tenon timber
-mortise timber
-tenon end (of the tenon timber)
-size (X,Y cross sectional size of tenon in local space of the tenon timber)
-tenon_length
-mortise_depth (must be >= to tenon length, if none, then it's a through mortise)
-tenon_rotation (ccw rotation of tenon, identity by default )
-wedges parameters (optional)
-peg parameters (otpional)


for implemntation, for now, assert on wedge and peg parameters being none, we will implement them later. also assert tenon_rotation is identity.


stub out the peg and wedge praameter classes below though

class SimplePegParameters
  shape: PegShape
  tenon_face: TimberLongFace # the face on the TENON timber that the pegs will be perpendicular too, only valid if tenon_rotation is identity
  peg_positions: [(Numeric, Numeric)] # first is in length axis measured from the shoulder of the tenon, the second is in the perpendicular axis measured from center
  depth: Optinoal[Numeric] # measured from mortise face where the peg goes in, none means peg goes all the way through to the other side
  length: length of the peg

class WedgeParameters
  shape: Wedge Shape
  depth: Numeric # depth of the wedge cut, note could be different than length of wedge
  width_axis: Direction3D # wedges run along this axis, so the, so when looking perpendicular to this and the length axis, you see the the trapezoidal "sides" of the wedges
  positions: [Numeric] # positions from center of the timber in the width axis
  expand_mortise: Numeric # amount to fan out the bottom of the mortise to fit the wedges, so 0 means straight sides, and X means expand both sides of the mortise bottom by X (total) from straight. 0 by default




:: 12/24/2025 reorg code notes


all core code should live in a "code_goes_here" folder
tests should exists side by side to code (not in their separate test folder)

-timber.py cotains all enums constants and types
-construction.py contains all our timber creation functions
-basic_joints.py contains all basic joint creation functions
-giraffe.py imports all files and rexports them together

don't touch fusion360, rhino, examples, oldcrap folder for now



::12/2025 BREP CUTTING OPERATIONS

make a generic B-rep cutting operations for doing most joints:

-very basic
  -shoulder plane 
    -specified by a position and a normal (infintie plane)
    -created relative to a timber end + direction
  -rectangular prism
    -easy for tenon ends
    -for mortises, do we use the joining timber to locate? Probably not,



Challenges:
- locating rectangular prisms from tenon and mortises
- infinet to finite bounds



:: 12/2025 timber joint rep and  timber length calculatino notes

-cut
  -substractive operation on timber
  -end cuts "set" the length of the timber (either extending it or shortening it) on the end it cut
    -ALTERNATIVE 
      -cut does not care, just does substractive cut. (this is kinda nice)
      -add suppor for infinite timbers (this is really nice)
      -unjointed end cuts can either 
        -be non infinte timber ends (a little ad-hoc)
        -we could use an end cut operation to size the timber (pro) (cumbersome, but most elegant)
  -if cutting on the bot (origin) end, the origin remains in the same place, so the final cut timber has a bottom point below 0
    -ALTERNATIVE: move origin to the very bottom always (ick?)

DECISION
  -timbers defined as is (with origin and length)
  -when a timber has a cut at the end, it becomes infinite in that direction
  -if it helps, you can think of timbers without an end cut as an infinite timber with a default end cut at the length
  
-joint
  -cuts on 1 ore more timbers that connect them


-Cut 
  -implementation detail (sorta)
  -happen at the CSG/brep level
  -if we do the extension thing
    -extending timber end includes cut
    -I guess could/should be used to infer timber length if we go with the "extension" method
  -TODO how are cuts defined, relative to timber origin or relative to a point/face on the timber?
    -maybe relative to timber, in which case a Cut class on its own is meaningless, maybe was well define TimberCut and then [TimberCut] for a list of cuts on a timber (at which point maybe just name it Cut)
-TimberCut
  -A timber with a series of Cuts on it
  -if we do the extension thing
    -has some face-cognition, meaning cuts happen relative to a face,  (this actualy only need)
      -only ends can be "extended", this is very much an ad-hoc operation
-Joint
  -a list of TimberCuts that form the joint
  -also includes joint accesories like draw bore,s fasteners, etc
-CutTimber
  -A timber with a list of TimberCuts?  


:: 11/2025 Reference Stuff

we want to introduce some kind of notion of "ReferencePoint/Line/Plane" for the purpose of positioning timbers relative to each other.
We'll call these classes "ReferenceFeature" 

For example:

I want to create 3 timbers like so:

      
      |
A-----|
  |   |
  |   |
  B   C  


so in this case, we want to use `join_timbers` and align it such that:
- the top face of timber A align with the top face of timber B
- the vertical position set above determines where it will connect with timber C



In general, we want to be able to take a ReferencePoint/Line/Plane of a timber and position that relative to another ReferencePoint/Line/Plane of a timber

We support the following ReferencePoint/Line/Plane of a timber

Timber Vertex  -> ReferencePoint
Timber Edge -> ReferenceLine
Timber Face -> ReferencePlane
Timber Centerline -> ReferenceLine
Timber Face + Timber Centerline -> ReferencePoint



Lets look at the current signature of join_timbers:

def join_timbers(timber1: Timber, timber2: Timber, 
                location_on_timber1: float,
                location_on_timber2: Optional[float] = None,
                lateral_offset: float = Integer(0),
                stickout: Stickout = None,  # Defaults to Stickout.nostickout()
                size: Optional[V2] = None,
                orientation_width_vector: Optional[Direction3D] = None) -> Timber:

In this case we want to be able to do the general positioning instead of just location_on_timber1

There are some limitations since we only have 1 DOF for positioning, in particular we must position against either the Reference Plane that is the top or bottom Face of timber1
In this case, the ReferenceFeature of Timber1 also carries an implicit direction argument, but perhaps we may as well imbue Reference Features with a direction vector? The direction vector must always be perpendicular to the line/plane. 
By convention, the directional vector coming out of an vertex/edge will be perpendicular to one of the faces that the vertex/edge lives on

For the ReferenceFeature of the created timber, it could be:

ReferencePoint
ReferenceLine/Plane that is parallel with ReferencePlane of timber 1




:: 11/2025 DONE Stickout

by default, join timbers joins between midline of timbers but often we want to join from the outside, so we should add modes to the stickout class like

stickoutReference1 / stickoutReference2

enum StickoutReference = CENTER_LINE | INSIDE | OUTSIDE


CENTER_LINE
joined timber
| |
||===== createdtimber
| |

INSIDE
joined timber
| |
| |===== createdtimber
| |

OUTSIDE
joined timber
| |
|====== createdtimber
| |


Also we should probbal yrename join_timbers to refere to timber1/2 as timberA/B instead