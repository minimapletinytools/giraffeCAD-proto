
:: Reference Stuff

we want to introduce some kind of notion of "ReferencePoint/Line/Plane" for the purpose of positioning timbers relative to each other.
We'll call these classes "ReferenceFeature" 

For example:

I want to create 3 timbers like so:

      
      |
A-----|
  |   |
  |   |
  B   C  


so in this case, we want to use `join_timbers` and align it such that:
- the top face of timber A align with the top face of timber B
- the vertical position set above determines where it will connect with timber C



In general, we want to be able to take a ReferencePoint/Line/Plane of a timber and position that relative to another ReferencePoint/Line/Plane of a timber

We support the following ReferencePoint/Line/Plane of a timber

Timber Vertex  -> ReferencePoint
Timber Edge -> ReferenceLine
Timber Face -> ReferencePlane
Timber Centerline -> ReferenceLine
Timber Face + Timber Centerline -> ReferencePoint



Lets look at the current signature of join_timbers:

def join_timbers(timber1: Timber, timber2: Timber, 
                location_on_timber1: float,
                location_on_timber2: Optional[float] = None,
                lateral_offset: float = Integer(0),
                stickout: Stickout = None,  # Defaults to Stickout.nostickout()
                size: Optional[V2] = None,
                orientation_width_vector: Optional[Direction3D] = None) -> Timber:

In this case we want to be able to do the general positioning instead of just location_on_timber1

There are some limitations since we only have 1 DOF for positioning, in particular we must position against either the Reference Plane that is the top or bottom Face of timber1
In this case, the ReferenceFeature of Timber1 also carries an implicit direction argument, but perhaps we may as well imbue Reference Features with a direction vector? The direction vector must always be perpendicular to the line/plane. 
By convention, the directional vector coming out of an vertex/edge will be perpendicular to one of the faces that the vertex/edge lives on

For the ReferenceFeature of the created timber, it could be:

ReferencePoint
ReferenceLine/Plane that is parallel with ReferencePlane of timber 1




:: documentation

-installation
-quick start 
-simple reference
  -simple examples of how to use each method with default parameters (axis aligned, face parallel only)
-terminology
  -detailed examples explaing all cnocepts
-advanced reference
  -detailed examples outlining every parameter
-appendix shit


:: TODO

-NEXT MILESTONE
  -address TODOS in join_timbers
  -create a split timber method that takes a timebr and returns 2 timbers (you splice joint themy ourself later)
  -consider making a better way to store TimberWithJoints
  -create list of joints to support and define their interfaces (spline, butt, corner, other)
  -add resultant length function after applying joints computerLength(timebr, [joints])
    -get fusino 360 to render just at the rusultant length 
  -get rhino rendering working for the following joints ...
  -improve examples
    -create series of examples showcasing each feature
    -create series of more complex examples
    -create test runner for examples so the exmaples are also tests :O
  -make shed example
  -update docs
    -write README intro
    -cleanup comments in code and delete morenotes.md
    -generate docs
    - you need a better way to specify timber lenghts... most of the time you don't really care? It should be determined by the joint in most cases.
      - so I guess joints will resize the timber, even tusk tenon joints take a tusk length parameter, tenon joints have a tenon depth parameter etc.. 
      - i think this is how it already is, update the README to explain this
    - move joint section from morenotes into concepts.md and then delete morenotes






- maybe split griaffe sad :(






:: FUTURE shit
-should we attach meta info to Timbers, it would be nice if timbers were aware of their location on the footprint to assist in finding reference faces for joint operations
- add nominal_size sup port for square and line rule desgins
- make really awesome examples that showcase each parameter of each function



:: TODONE

DONE-rename FootprintLocation to footprint location Type
DONE- getInside/OutsideFace(timber, footprint)
DNOE- getFacingFace(tiber, direction)
IGNORE- create readme
DONE- cleaunp morenotes (maybe delete it, all comments should be in code)
DONE- start working on docs
DONE- axis aligned timbers
DONE- rename face aligned to face parallel timebers
DONE- 2 faces can be oriented (same normals) or opposing (opposite normals)
DONE-rename "width vector" to "plus_x_width_vector" or "plus_x_width_vector_of_created_timber"
DONE-add helper asserts that does symbolic check if ratinoal otherwise fuzzy
  -check_parallel,perpendicular
DONE- note down default orientation of timbers when created in vertical and horizontal position
  - when laying horizontal, the orientation should always be consistent such that either the width or height of the timber runs in the Z axis direction
DONE/IGNORE- update timber join functions to only care about timber axis vs faces (X/widhth axis, and Y/height axis)

IGNORE- update timebr sizing notes so its really clear which size is which axis
DONE- decide on default orientation for horizontal timebrs
DONE- decide on default orinatiton for vertical timebrs on footprint
IGNORE- update join_timber to  only take axis to align with up/down rather tha face (I guess you can add a flip180 optional parameter....)
IGNORE- cerate join_timebr_raw that takes a raw face normal 
IGNORE- you need a better system for determining timber orientation after each timber creation operation, have sensible defaults 
  IGNORE- when joining 2 vertical timberss top face always faces up by default
  IGNORE- when joniing 2 horizontal timbers, top face laways faces?
  IGNORE- can you throw in a footprint to control which side top fac faces??



:: END TODONE

:: DONE Stickout

by default, join timbers joins between midline of timbers but often we want to join from the outside, so we should add modes to the stickout class like

stickoutReference1 / stickoutReference2

enum StickoutReference = CENTER_LINE | INSIDE | OUTSIDE


CENTER_LINE
joined timber
| |
||===== createdtimber
| |

INSIDE
joined timber
| |
| |===== createdtimber
| |

OUTSIDE
joined timber
| |
|====== createdtimber
| |


Also we should probbal yrename join_timbers to refere to timber1/2 as timberA/B instead